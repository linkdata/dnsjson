
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>dnsjson: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/linkdata/dnsjson/dnsjson.go (58.2%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Package dnsjson provides JSON marshalling/unmarshalling helpers for github.com/miekg/dns *dns.Msg
// using an explicit, human-readable JSON schema (no wire-format fields).
//
// Schema overview (stable keys; rdata keys per RR type listed below):
// {
//   "id": 1234,
//   "msgHdr": {"qr":true, "opcode":"QUERY", "aa":false, "tc":false, "rd":true,
//               "ra":true, "z":0, "ad":false, "cd":false, "rcode":"NOERROR"},
//   "question": [{"name":"example.com.", "qtype":"A", "qclass":"IN"}],
//   "answer":  [ RRJSON, ... ],
//   "ns":      [ RRJSON, ... ],
//   "extra":   [ RRJSON, ... ]
// }
//
// RRJSON (common fields) + per-type data (examples):
// {
//   "name":"example.com.", "type":"A", "class":"IN", "ttl":300,
//   "data": { "a":"93.184.216.34" }
// }
// AAAA: {"aaaa":"2001:db8::1"}
// CNAME: {"target":"alias.example."}
// NS: {"ns":"ns1.example."}
// PTR: {"ptr":"host.example."}
// TXT: {"txt":["chunk1","chunk2"]}
// MX: {"preference":10, "mx":"mail.example."}
// SRV: {"priority":0, "weight":5, "port":443, "target":"svc.example."}
// SOA: {"ns":"ns1.", "mbox":"hostmaster.", "serial":1, "refresh":7200, "retry":900, "expire":1209600, "minttl":300}
// CAA: {"flag":0, "tag":"issue", "value":"letsencrypt.org"}
// NAPTR: {"order":100, "preference":50, "flags":"s", "services":"SIP+D2U", "regexp":"", "replacement":"_sip._udp.example."}
// DS: {"key_tag":12345, "algorithm":8, "digest_type":2, "digest":"...hex..."}
// DNSKEY: {"flags":257, "protocol":3, "algorithm":8, "public_key":"base64..."}
// RRSIG: {"type_covered":"A", "algorithm":8, "labels":2, "original_ttl":300,
//         "expiration": 1735689600, "inception": 1733097600, "key_tag":12345,
//         "signer_name":"example.", "signature":"base64..."}
// TLSA: {"usage":3, "selector":1, "matching_type":1, "cert_data":"hex or base64"}
//
// Notes
//  - Type/class use standard mnemonics (e.g., "A", "AAAA", "IN").
//  - Unknown/less-common RR types are round-tripped via a best-effort map in "data"; if a
//    type is not implemented below, Marshal will include {"raw": "&lt;presentation&gt;"} and
//    Unmarshal will parse it using dns.NewRR on a synthesized presentation string.
//  - Times in RRSIG use UNIX seconds per miekg/dns conventions.

package dnsjson

import (
        "encoding/json"
        "errors"
        "fmt"
        "net/netip"
        "strconv"
        "strings"

        "github.com/miekg/dns"
)

type Msg dns.Msg

var _ json.Marshaler = &amp;Msg{}
var _ json.Unmarshaler = &amp;Msg{}

// MessageJSON is the top-level JSON shape for dns.Msg.
type MessageJSON struct {
        ID       uint16     `json:"id"`
        MsgHdr   MsgHdr     `json:"msgHdr"`
        Question []Question `json:"question"`
        Answer   []RRJSON   `json:"answer,omitempty"`
        Ns       []RRJSON   `json:"ns,omitempty"`
        Extra    []RRJSON   `json:"extra,omitempty"`
}

type MsgHdr struct {
        QR     bool   `json:"qr,omitempty"`
        Opcode string `json:"opcode"`
        AA     bool   `json:"aa,omitempty"`
        TC     bool   `json:"tc,omitempty"`
        RD     bool   `json:"rd,omitempty"`
        RA     bool   `json:"ra,omitempty"`
        Z      bool   `json:"z,omitempty"`
        AD     bool   `json:"ad,omitempty"`
        CD     bool   `json:"cd,omitempty"`
        Rcode  string `json:"rcode"`
}

type Question struct {
        Name   string `json:"name"`
        Qtype  string `json:"qtype"`
        Qclass string `json:"qclass"`
}

// RRJSON contains common RR header fields plus a per-type data map.
type RRJSON struct {
        Name  string         `json:"name"`
        Type  string         `json:"type"`
        Class string         `json:"class"`
        TTL   uint32         `json:"ttl"`
        Data  map[string]any `json:"data"`
}

func (m *Msg) MarshalJSON() ([]byte, error) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return []byte("null"), nil
        }</span>
        <span class="cov8" title="1">j := MessageJSON{
                ID:     m.Id,
                MsgHdr: hdrToJSON(m.MsgHdr),
        }
        // Questions
        for _, q := range m.Question </span><span class="cov8" title="1">{
                j.Question = append(j.Question, Question{
                        Name:   q.Name,
                        Qtype:  typeToString(q.Qtype),
                        Qclass: classToString(q.Qclass),
                })
        }</span>
        // Sections
        <span class="cov8" title="1">j.Answer = rrsToJSON(m.Answer)
        j.Ns = rrsToJSON(m.Ns)
        j.Extra = rrsToJSON(m.Extra)
        return json.Marshal(j)</span>
}

func (msg *Msg) UnmarshalJSON(data []byte) error <span class="cov8" title="1">{
        if len(data) == 0 </span><span class="cov0" title="0">{
                return errors.New("dnsjson: empty input")
        }</span>
        <span class="cov8" title="1">var raw json.RawMessage
        if err := json.Unmarshal(data, &amp;raw); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("dnsjson: invalid JSON: %w", err)
        }</span>
        <span class="cov8" title="1">if string(raw) == "null" </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">var j MessageJSON
        if err := json.Unmarshal(raw, &amp;j); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("dnsjson: invalid message: %w", err)
        }</span>

        <span class="cov8" title="1">msg.Id = j.ID
        msg.MsgHdr = hdrFromJSON(j.MsgHdr)
        // Questions
        for _, qj := range j.Question </span><span class="cov8" title="1">{
                qt, err := stringToType(qj.Qtype)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("dnsjson: question qtype: %w", err)
                }</span>
                <span class="cov8" title="1">qc, err := stringToClass(qj.Qclass)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("dnsjson: question qclass: %w", err)
                }</span>
                <span class="cov8" title="1">msg.Question = append(msg.Question, dns.Question{Name: qj.Name, Qtype: qt, Qclass: qc})</span>
        }
        // Sections
        <span class="cov8" title="1">var err error
        if msg.Answer, err = rrsFromJSON(j.Answer); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("answer: %w", err)
        }</span>
        <span class="cov8" title="1">if msg.Ns, err = rrsFromJSON(j.Ns); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("ns: %w", err)
        }</span>
        <span class="cov8" title="1">if msg.Extra, err = rrsFromJSON(j.Extra); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("extra: %w", err)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// --- helpers ---

func hdrToJSON(h dns.MsgHdr) MsgHdr <span class="cov8" title="1">{
        return MsgHdr{
                QR:     h.Response,
                Opcode: dns.OpcodeToString[h.Opcode],
                AA:     h.Authoritative,
                TC:     h.Truncated,
                RD:     h.RecursionDesired,
                RA:     h.RecursionAvailable,
                Z:      h.Zero,
                AD:     h.AuthenticatedData,
                CD:     h.CheckingDisabled,
                Rcode:  dns.RcodeToString[h.Rcode],
        }
}</span>

func hdrFromJSON(j MsgHdr) (mh dns.MsgHdr) <span class="cov8" title="1">{
        mh.Response = j.QR
        mh.Opcode = stringToOpcode(j.Opcode)
        mh.Authoritative = j.AA
        mh.Truncated = j.TC
        mh.RecursionDesired = j.RD
        mh.RecursionAvailable = j.RA
        mh.Zero = j.Z
        mh.AuthenticatedData = j.AD
        mh.CheckingDisabled = j.CD
        mh.Rcode = stringToRcode(j.Rcode)
        return
}</span>

func rrsToJSON(rrs []dns.RR) (out []RRJSON) <span class="cov8" title="1">{
        for _, rr := range rrs </span><span class="cov0" title="0">{
                out = append(out, rrToJSON(rr))
        }</span>
        <span class="cov8" title="1">return</span>
}

func rrsFromJSON(rrjs []RRJSON) (out []dns.RR, err error) <span class="cov8" title="1">{
        for _, j := range rrjs </span><span class="cov8" title="1">{
                if rr, e := rrFromJSON(j); e == nil </span><span class="cov8" title="1">{
                        out = append(out, rr)
                }</span> else<span class="cov8" title="1"> {
                        err = errors.Join(err, e)
                }</span>
        }
        <span class="cov8" title="1">return</span>
}

func rrToJSON(rr dns.RR) RRJSON <span class="cov0" title="0">{
        h := rr.Header()
        j := RRJSON{
                Name:  h.Name,
                Type:  typeToString(h.Rrtype),
                Class: classToString(h.Class),
                TTL:   h.Ttl,
                Data:  map[string]any{},
        }
        switch v := rr.(type) </span>{
        case *dns.A:<span class="cov0" title="0">
                j.Data["a"] = v.A.String()</span>
        case *dns.AAAA:<span class="cov0" title="0">
                j.Data["aaaa"] = v.AAAA.String()</span>
        case *dns.CNAME:<span class="cov0" title="0">
                j.Data["target"] = v.Target</span>
        case *dns.NS:<span class="cov0" title="0">
                j.Data["ns"] = v.Ns</span>
        case *dns.PTR:<span class="cov0" title="0">
                j.Data["ptr"] = v.Ptr</span>
        case *dns.TXT:<span class="cov0" title="0">
                j.Data["txt"] = append([]string(nil), v.Txt...)</span>
        case *dns.MX:<span class="cov0" title="0">
                j.Data["preference"] = v.Preference
                j.Data["mx"] = v.Mx</span>
        case *dns.SRV:<span class="cov0" title="0">
                j.Data["priority"] = v.Priority
                j.Data["weight"] = v.Weight
                j.Data["port"] = v.Port
                j.Data["target"] = v.Target</span>
        case *dns.SOA:<span class="cov0" title="0">
                j.Data["ns"] = v.Ns
                j.Data["mbox"] = v.Mbox
                j.Data["serial"] = v.Serial
                j.Data["refresh"] = v.Refresh
                j.Data["retry"] = v.Retry
                j.Data["expire"] = v.Expire
                j.Data["minttl"] = v.Minttl</span>
        case *dns.CAA:<span class="cov0" title="0">
                j.Data["flag"] = v.Flag
                j.Data["tag"] = v.Tag
                j.Data["value"] = v.Value</span>
        case *dns.NAPTR:<span class="cov0" title="0">
                j.Data["order"] = v.Order
                j.Data["preference"] = v.Preference
                j.Data["flags"] = v.Flags
                j.Data["service"] = v.Service
                j.Data["regexp"] = v.Regexp
                j.Data["replacement"] = v.Replacement</span>
        case *dns.DS:<span class="cov0" title="0">
                j.Data["key_tag"] = v.KeyTag
                j.Data["algorithm"] = v.Algorithm
                j.Data["digest_type"] = v.DigestType
                j.Data["digest"] = strings.ToLower(v.Digest)</span>
        case *dns.DNSKEY:<span class="cov0" title="0">
                j.Data["flags"] = v.Flags
                j.Data["protocol"] = v.Protocol
                j.Data["algorithm"] = v.Algorithm
                j.Data["public_key"] = v.PublicKey</span>
        case *dns.RRSIG:<span class="cov0" title="0">
                j.Data["type_covered"] = typeToString(v.TypeCovered)
                j.Data["algorithm"] = v.Algorithm
                j.Data["labels"] = v.Labels
                j.Data["original_ttl"] = v.OrigTtl
                j.Data["expiration"] = v.Expiration
                j.Data["inception"] = v.Inception
                j.Data["key_tag"] = v.KeyTag
                j.Data["signer_name"] = v.SignerName
                j.Data["signature"] = v.Signature</span>
        case *dns.TLSA:<span class="cov0" title="0">
                j.Data["usage"] = v.Usage
                j.Data["selector"] = v.Selector
                j.Data["matching_type"] = v.MatchingType
                j.Data["cert_data"] = v.Certificate</span>
        default:<span class="cov0" title="0">
                // Fallback to presentation for unknown types to maintain coverage without wire format.
                j.Data["raw"] = rr.String()</span>
        }
        <span class="cov0" title="0">return j</span>
}

func rrFromJSON(j RRJSON) (rr dns.RR, err error) <span class="cov8" title="1">{
        var typeCode, classCode uint16
        if typeCode, err = stringToType(j.Type); err == nil </span><span class="cov8" title="1">{
                if classCode, err = stringToClass(j.Class); err == nil </span><span class="cov8" title="1">{
                        // Choose concrete by type
                        switch typeCode </span>{
                        case dns.TypeA:<span class="cov8" title="1">
                                var ip netip.Addr
                                if ip, err = netip.ParseAddr(getString(j.Data, "a")); err == nil </span><span class="cov8" title="1">{
                                        if ip.Is4() </span><span class="cov8" title="1">{
                                                rr = &amp;dns.A{
                                                        Hdr: rrHdr(j, typeCode, classCode),
                                                        A:   ip.AsSlice(),
                                                }
                                        }</span>
                                }
                        case dns.TypeAAAA:<span class="cov0" title="0">
                                var ip netip.Addr
                                if ip, err = netip.ParseAddr(getString(j.Data, "aaaa")); err == nil </span><span class="cov0" title="0">{
                                        if ip.Is6() </span><span class="cov0" title="0">{
                                                rr = &amp;dns.AAAA{
                                                        Hdr:  rrHdr(j, typeCode, classCode),
                                                        AAAA: ip.AsSlice(),
                                                }
                                        }</span>
                                }
                        case dns.TypeCNAME:<span class="cov0" title="0">
                                rr = &amp;dns.CNAME{
                                        Hdr:    rrHdr(j, typeCode, classCode),
                                        Target: getString(j.Data, "target"),
                                }</span>
                        case dns.TypeNS:<span class="cov0" title="0">
                                rr = &amp;dns.NS{
                                        Hdr: rrHdr(j, typeCode, classCode),
                                        Ns:  getString(j.Data, "ns"),
                                }</span>
                        case dns.TypePTR:<span class="cov0" title="0">
                                rr = &amp;dns.PTR{
                                        Hdr: rrHdr(j, typeCode, classCode),
                                        Ptr: getString(j.Data, "ptr"),
                                }</span>
                        case dns.TypeTXT:<span class="cov0" title="0">
                                var arr []string
                                if arr, err = getStringSlice(j.Data, "txt"); err == nil </span><span class="cov0" title="0">{
                                        rr = &amp;dns.TXT{
                                                Hdr: rrHdr(j, typeCode, classCode),
                                                Txt: arr,
                                        }
                                }</span>
                        case dns.TypeMX:<span class="cov0" title="0">
                                rr = &amp;dns.MX{
                                        Hdr:        rrHdr(j, typeCode, classCode),
                                        Preference: getUint16(j.Data, "preference"),
                                        Mx:         getString(j.Data, "mx"),
                                }</span>
                        case dns.TypeSRV:<span class="cov0" title="0">
                                rr = &amp;dns.SRV{
                                        Hdr:      rrHdr(j, typeCode, classCode),
                                        Priority: getUint16(j.Data, "priority"),
                                        Weight:   getUint16(j.Data, "weight"),
                                        Port:     getUint16(j.Data, "port"),
                                        Target:   getString(j.Data, "target"),
                                }</span>
                        case dns.TypeSOA:<span class="cov0" title="0">
                                rr = &amp;dns.SOA{
                                        Hdr:     rrHdr(j, typeCode, classCode),
                                        Ns:      getString(j.Data, "ns"),
                                        Mbox:    getString(j.Data, "mbox"),
                                        Serial:  getUint32(j.Data, "serial"),
                                        Refresh: getUint32(j.Data, "refresh"),
                                        Retry:   getUint32(j.Data, "retry"),
                                        Expire:  getUint32(j.Data, "expire"),
                                        Minttl:  getUint32(j.Data, "minttl"),
                                }</span>
                        case dns.TypeCAA:<span class="cov0" title="0">
                                rr = &amp;dns.CAA{
                                        Hdr:   rrHdr(j, typeCode, classCode),
                                        Flag:  getUint8(j.Data, "flag"),
                                        Tag:   getString(j.Data, "tag"),
                                        Value: getString(j.Data, "value"),
                                }</span>
                        case dns.TypeNAPTR:<span class="cov0" title="0">
                                rr = &amp;dns.NAPTR{
                                        Hdr:         rrHdr(j, typeCode, classCode),
                                        Order:       getUint16(j.Data, "order"),
                                        Preference:  getUint16(j.Data, "preference"),
                                        Flags:       getString(j.Data, "flags"),
                                        Service:     getString(j.Data, "service"),
                                        Regexp:      getString(j.Data, "regexp"),
                                        Replacement: getString(j.Data, "replacement"),
                                }</span>
                        case dns.TypeDS:<span class="cov0" title="0">
                                rr = &amp;dns.DS{
                                        Hdr:        rrHdr(j, typeCode, classCode),
                                        KeyTag:     getUint16(j.Data, "key_tag"),
                                        Algorithm:  getUint8(j.Data, "algorithm"),
                                        DigestType: getUint8(j.Data, "digest_type"),
                                        Digest:     strings.ToUpper(getString(j.Data, "digest")),
                                }</span>
                        case dns.TypeDNSKEY:<span class="cov0" title="0">
                                rr = &amp;dns.DNSKEY{
                                        Hdr:       rrHdr(j, typeCode, classCode),
                                        Flags:     getUint16(j.Data, "flags"),
                                        Protocol:  getUint8(j.Data, "protocol"),
                                        Algorithm: getUint8(j.Data, "algorithm"),
                                        PublicKey: getString(j.Data, "public_key"),
                                }</span>
                        case dns.TypeRRSIG:<span class="cov0" title="0">
                                var cov uint16
                                if cov, err = stringToType(getString(j.Data, "type_covered")); err == nil </span><span class="cov0" title="0">{
                                        rr = &amp;dns.RRSIG{
                                                Hdr:         rrHdr(j, typeCode, classCode),
                                                TypeCovered: cov,
                                                Algorithm:   getUint8(j.Data, "algorithm"),
                                                Labels:      getUint8(j.Data, "labels"),
                                                OrigTtl:     getUint32(j.Data, "original_ttl"),
                                                Expiration:  getUint32(j.Data, "expiration"),
                                                Inception:   getUint32(j.Data, "inception"),
                                                KeyTag:      getUint16(j.Data, "key_tag"),
                                                SignerName:  getString(j.Data, "signer_name"),
                                                Signature:   getString(j.Data, "signature"),
                                        }
                                }</span>
                        case dns.TypeTLSA:<span class="cov0" title="0">
                                rr = &amp;dns.TLSA{
                                        Hdr:          rrHdr(j, typeCode, classCode),
                                        Usage:        getUint8(j.Data, "usage"),
                                        Selector:     getUint8(j.Data, "selector"),
                                        MatchingType: getUint8(j.Data, "matching_type"),
                                        Certificate:  getString(j.Data, "cert_data"),
                                }</span>
                        default:<span class="cov8" title="1">
                                // Best-effort fallback using presentation format stored in data.raw
                                raw := getString(j.Data, "raw")
                                if raw == "" </span><span class="cov0" title="0">{
                                        // try to synthesize: "Name TTL Class Type &lt;empty&gt;"
                                        raw = fmt.Sprintf("%s %d %s %s", j.Name, j.TTL, j.Class, j.Type)
                                }</span>
                                <span class="cov8" title="1">if rr, err = dns.NewRR(raw); err == nil </span><span class="cov8" title="1">{
                                        // NewRR does not preserve TTL/class/name from header in raw string if omitted; ensure header set
                                        h := rr.Header()
                                        h.Name, h.Class, h.Rrtype, h.Ttl = j.Name, classCode, typeCode, j.TTL
                                        rr.Header().Name = h.Name
                                        rr.Header().Class = h.Class
                                        rr.Header().Rrtype = h.Rrtype
                                        rr.Header().Ttl = h.Ttl
                                }</span>
                        }
                }
        }
        <span class="cov8" title="1">return</span>
}

func rrHdr(j RRJSON, t uint16, c uint16) dns.RR_Header <span class="cov8" title="1">{
        return dns.RR_Header{Name: j.Name, Rrtype: t, Class: c, Ttl: j.TTL}
}</span>

// --- mapping helpers ---

func typeToString(t uint16) (s string) <span class="cov8" title="1">{
        var ok bool
        if s, ok = dns.TypeToString[t]; !ok </span><span class="cov8" title="1">{
                s = strconv.FormatUint(uint64(t), 10)
        }</span>
        <span class="cov8" title="1">return</span>
}

func stringToType(s string) (typ uint16, err error) <span class="cov8" title="1">{
        var ok bool
        if typ, ok = dns.StringToType[strings.ToUpper(s)]; !ok </span><span class="cov8" title="1">{
                var n uint64
                if n, err = strconv.ParseUint(s, 10, 16); err == nil </span><span class="cov8" title="1">{
                        typ = uint16(n)
                }</span> else<span class="cov8" title="1"> {
                        err = fmt.Errorf("unknown type %q", s)
                }</span>
        }
        <span class="cov8" title="1">return</span>
}

func classToString(c uint16) (s string) <span class="cov8" title="1">{
        var ok bool
        if s, ok = dns.ClassToString[c]; !ok </span><span class="cov8" title="1">{
                s = strconv.FormatUint(uint64(c), 10)
        }</span>
        <span class="cov8" title="1">return</span>
}

func stringToClass(s string) (cls uint16, err error) <span class="cov8" title="1">{
        var ok bool
        if cls, ok = dns.StringToClass[strings.ToUpper(s)]; !ok </span><span class="cov8" title="1">{
                var n uint64
                if n, err = strconv.ParseUint(s, 10, 16); err == nil </span><span class="cov8" title="1">{
                        cls = uint16(n)
                }</span> else<span class="cov8" title="1"> {
                        err = fmt.Errorf("unknown class %q", s)
                }</span>
        }
        <span class="cov8" title="1">return</span>
}

func stringToOpcode(s string) (opcode int) <span class="cov8" title="1">{
        opcode = dns.OpcodeQuery
        if op, ok := dns.StringToOpcode[strings.ToUpper(s)]; ok </span><span class="cov8" title="1">{
                opcode = op
        }</span>
        <span class="cov8" title="1">return</span>
}

func stringToRcode(s string) (rcode int) <span class="cov8" title="1">{
        rcode = dns.RcodeSuccess
        if rc, ok := dns.StringToRcode[strings.ToUpper(s)]; ok </span><span class="cov8" title="1">{
                rcode = rc
        }</span>
        <span class="cov8" title="1">return</span>
}

// --- small JSON helpers ---

func getString(m map[string]any, key string) (s string) <span class="cov8" title="1">{
        if m != nil </span><span class="cov8" title="1">{
                if v, ok := m[key]; ok </span><span class="cov8" title="1">{
                        s, _ = v.(string)
                }</span>
        }
        <span class="cov8" title="1">return</span>
}

func getUint8(m map[string]any, key string) uint8 <span class="cov8" title="1">{
        return uint8(getInt(m, key)) // #nosec G115
}</span>
func getUint16(m map[string]any, key string) uint16 <span class="cov8" title="1">{
        return uint16(getInt(m, key)) // #nosec G115
}</span>
func getUint32(m map[string]any, key string) uint32 <span class="cov8" title="1">{
        return uint32(getInt(m, key)) // #nosec G115
}</span>

func getInt(m map[string]any, key string) (n int64) <span class="cov8" title="1">{
        if m != nil </span><span class="cov8" title="1">{
                if v, ok := m[key]; ok </span><span class="cov8" title="1">{
                        switch t := v.(type) </span>{
                        case float64:<span class="cov8" title="1">
                                n = int64(t)</span>
                        case int:<span class="cov8" title="1">
                                n = int64(t)</span>
                        case int64:<span class="cov8" title="1">
                                n = t</span>
                        case json.Number:<span class="cov8" title="1">
                                n, _ = t.Int64()</span>
                        case string:<span class="cov8" title="1">
                                n, _ = strconv.ParseInt(t, 10, 64)</span>
                        }
                }
        }
        <span class="cov8" title="1">return</span>
}

func getStringSlice(m map[string]any, key string) (out []string, err error) <span class="cov8" title="1">{
        if v, ok := m[key]; ok </span><span class="cov8" title="1">{
                a, ok := v.([]any)
                if !ok </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("%s must be array of strings", key)
                }</span>
                <span class="cov8" title="1">for _, it := range a </span><span class="cov8" title="1">{
                        s, ok := it.(string)
                        if !ok </span><span class="cov8" title="1">{
                                return nil, fmt.Errorf("%s must be array of strings", key)
                        }</span>
                        <span class="cov8" title="1">out = append(out, s)</span>
                }
        }
        <span class="cov8" title="1">return</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
